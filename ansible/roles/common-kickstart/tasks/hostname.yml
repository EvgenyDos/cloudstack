## Setting the hostname sounds easy, and it would be - if we didnt have to hack around kickstart/nic naming issues

### 
### Background:
## Most if not all of the Dell hosts will boot into kickstart and have a 'em1' and 'em2', which is not the interface
## name when the host has completed the OS installation (they then become enoX).  This fact makes not only 
## The detection of the hostname hard (via Reverse DNS name) but tricky to setup the Bond interfaces
## since we need to specifically name the interfaces in the bond.
##  Example: once the host reboots after install, if we blindly assumed the interface named were the same 
##           then the bonds subinterfaces would be em1 and em2, which no longer exist as they would need
##           to be enop1 and enop2 for example

##
## START hostname Detection by interfaces
##
### if we are in 'kickstart_hack' (determined in networking.yml) mode, then we just use information for em1/em2 and skip
### looking at the real interfaces since they do not exist yet in Kickstart

### If em1 has resolvable IP
- name: Get Reverse Record of em1
  shell: host {{ ansible_em1.ipv4.address }} | awk '{print $NF}' | sed 's/\.$//'|grep -v NXDOMAIN
  register: hostname_em1
  when: ansible_em1 is defined and kickstart_hack is defined

- name: Get Default Route for em1
  shell: ip route show dev em1 proto static | awk '{print $3}'
  register: em1_default_route
  when: ansible_em1 is defined and kickstart_hack is defined

### If em2 has resolvable IP
- name: Get Reverse Record of em2
  shell: host {{ ansible_em2.ipv4.address }} | awk '{print $NF}' | sed 's/\.$//'|grep -v NXDOMAIN
  register: hostname_em2
  when: ansible_em2 is defined and kickstart_hack is defined
  ignore_errors: true

- name: Get Default Route for em2
  shell: ip route show dev em2 proto static | awk '{print $3}'
  register: em2_default_route
  when: ansible_em2 is defined and kickstart_hack is defined
  ignore_errors: true


- name: Using IP and Hostname on Primary Kickstart Interface [em1] for the bond
  set_fact:
    custom_hostname: "{{ hostname_em1.stdout }}"
    tm_bond_ip: "{{ ansible_em1.ipv4.address }}"
    tm_bond_netmask: "{{ ansible_em1.ipv4.netmask }}"
    tm_bond_gateway: "{{ em1_default_route.stdout }}"
  when: kickstart_hack is defined

- name: Using IP and Hostname on Secondary Kickstart Interface [em2] for the bond
  set_fact:
    custom_hostname: "{{ hostname_em2.stdout }}"
    tm_bond_ip: "{{ ansible_em2.ipv4.address }}"
    tm_bond_netmask: "{{ ansible_em2.ipv4.netmask }}"
    tm_bond_gateway: "{{ em2_default_route.stdout }}"
  when: (kickstart_hack is defined) and (custom_hostname is not defined) and (hostname_em1.rc == 0)

## If we are NOT in kickstart_hack mode
## Here we do something ugly and use external tools to lookup facts because ansible doesnt support variable expansion
### if Primary Interface has resolvable IP

# Primary Interface:
## Get IP for DNS lookup
- name: Look for IP Information on Interface [{{ tm_primary_interface }}]
  shell: /sbin/ip addr list {{ tm_primary_interface }} |grep "inet "|cut -d' ' -f6|cut -d/ -f1 | grep '\.'
  register: tm_primary_interface_ip
  ignore_errors: true
  when: (kickstart_hack is not defined) and (tm_primary_interface is defined)

## Get Hostname from IP
- name: Get Reverse Record of [{{ tm_primary_interface }}]
  shell: host {{ tm_primary_interface_ip.stdout }} | awk '{print $NF}' | sed 's/\.$//'|grep -v NXDOMAIN
  register: tm_primary_interface_hostname
  when: (kickstart_hack is not defined) and (tm_primary_interface_ip is defined) and (tm_primary_interface_ip.rc == 0)
  ignore_errors: true

# Get Netmask of IP
- name: Getting Netmask from [{{ tm_primary_interface }}]
  shell: /sbin/ifconfig {{ tm_primary_interface }} | awk '/netmask/{ print $4;}'
  register: tm_primary_interface_netmask
  when: (kickstart_hack is not defined) and (tm_primary_interface_ip is defined) and (tm_primary_interface_ip.rc == 0)
  ignore_errors: true

# Get Default route on interfaces_file - the 'grep default' is just there so we can detect an exit code :/
- name: Getting Default Route from [{{ tm_primary_interface }}]
  shell: /sbin/ip -4 route list type unicast dev {{ tm_primary_interface }} exact 0/0 | grep default | awk '{print $3}'
  register: tm_primary_interface_gateway
  when: (kickstart_hack is not defined) and (tm_primary_interface_ip is defined)
  ignore_errors: true

# Secondary Interface:
## Get IP For DNS lookup
- name: Look for IP Information on Interface {{ tm_secondary_interface }}
  shell: /sbin/ip addr list {{ tm_secondary_interface }} |grep "inet " |cut -d' ' -f6|cut -d/ -f1 | grep '\.'
  register: tm_secondary_interface_ip
  ignore_errors: true
  when: (kickstart_hack is not defined) and (tm_secondary_interface is defined)

## Get Hostname from IP
- name: Get Reverse Record of {{ tm_secondary_interface }}
  shell: host {{ tm_secondary_interface_ip.stdout }} | awk '{print $NF}' | sed 's/\.$//'|grep -v NXDOMAIN
  register: tm_secondary_interface_hostname
  when: (kickstart_hack is not defined) and (tm_secondary_interface_ip is defined) and (tm_secondary_interface_ip.rc == 0)
  ignore_errors: true

# Get Netmask of IP
- name: Getting Netmask from [{{ tm_secondary_interface }}]
  shell: /sbin/ifconfig {{ tm_secondary_interface }} | awk '/netmask/{ print $4;}'
  register: tm_secondary_interface_netmask
  when: (kickstart_hack is not defined) and (tm_secondary_interface_ip is defined) and (tm_secondary_interface_ip.rc == 0)
  ignore_errors: true

# Get Default route on interface - the 'grep default' is just there so we can detect an exit code :/
- name: Getting Default Route from [{{ tm_secondary_interface }}]
  shell: /sbin/ip -4 route list type unicast dev {{ tm_secondary_interface }} exact 0/0 | grep default | awk '{print $3}'
  register: tm_secondary_interface_gateway
  when: (kickstart_hack is not defined) and (tm_secondary_interface is defined)
  ignore_errors: true

## Now that we have checked both primary and secondary interfaces for a valid hostname (via Reverse DNS record)
## we can establish which one to use for the Bond.  By Default use Primary, Fall-back to secondary
- name: Using IP and Hostname on Primary Interface [{{ tm_primary_interface }}] for the bond
  set_fact:
    custom_hostname: "{{ tm_primary_interface_hostname.stdout }}"
    tm_bond_ip: "{{ tm_primary_interface_ip.stdout }}"
    tm_bond_netmask: "{{ tm_primary_interface_netmask.stdout }}"
    tm_bond_gateway: "{{ tm_primary_interface_gateway.stdout }}"
    tm_primary_interface_good: true
  ignore_errors: true
  when: (custom_hostname is not defined) and (tm_primary_interface_hostname is defined and tm_primary_interface_hostname.rc == 0)


- name: Using IP and Hostname on Secondary Interface [{{ tm_secondary_interface }}] for the bond
  set_fact:
    custom_hostname: "{{ tm_secondary_interface_hostname.stdout }}"
    tm_bond_ip: "{{ tm_secondary_interface_ip.stdout }}"
    tm_bond_netmask: "{{ tm_secondary_interface_netmask.stdout }}"
    tm_bond_gateway: "{{ tm_secondary_interface_gateway.stdout }}"
    tm_secondary_interface_good: true
  ignore_errors: true
  when: (custom_hostname is not defined) and (tm_secondary_interface_hostname is defined and tm_secondary_interface_hostname.rc == 0)

- name: Print Final Hostname Info
  debug: msg="Hostname {{ custom_hostname }}"

- name: Print Final IP Info
  debug: msg="Primary IP {{ tm_bond_ip }}"

- name: Print Final Netmask Info
  debug: msg="Netmask {{ tm_bond_netmask }}"
    
- name: Print Final Gateway Info
  debug: msg="Gateway {{ tm_bond_gateway }}"
 
## END hostname Detection by interfaces
##

# This SHOULD FAIL if the above conditions will not complete
- name: Populate a HOSTNAME in /etc/sysconfig/network file
  copy:
    content: "HOSTNAME={{ custom_hostname }}"
    dest: /etc/sysconfig/network
    force: yes
    group: root
    owner: root
    mode: 0644

- name: Create /etc/hostname file
  copy:
    content: "{{ custom_hostname }}"
    dest: /etc/hostname
    force: yes
    group: root
    owner: root
    mode: 0644

- name: Update /etc/hosts
  lineinfile:
    path: /etc/hosts
    regexp: '^{{ tm_bond_ip }}.*'
    line: "{{ tm_bond_ip }} {{ custom_hostname }}"
    state: present
    backrefs: yes

#- debug: msg="Hostname should be set to {{ custom_hostname }}"
